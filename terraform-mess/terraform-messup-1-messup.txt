Last login: Fri Oct 16 17:14:19 on ttys003
dap@zathras cockroachdb-testing-orig $ cd ..
dap@zathras oxide $ git clone cockroachdb-testing-orig/ cockroachdb-testing-test
Cloning into 'cockroachdb-testing-test'...
done.
dap@zathras oxide $ cd !$
cd cockroachdb-testing-test
dap@zathras cockroachdb-testing-test $ cp ../cockroachdb-testing-orig/terraform
terraform/         terraform-key      terraform-key.pub  
dap@zathras cockroachdb-testing-test $ cd terraform/
dap@zathras terraform $ terraform init

Initializing the backend...

Successfully configured the backend "s3"! Terraform will automatically
use this backend unless the backend configuration changes.

Initializing provider plugins...
- Finding hashicorp/aws versions matching "~> 2.0"...
- Finding hashicorp/null versions matching "2.1.2"...
- Installing hashicorp/aws v2.70.0...
- Installed hashicorp/aws v2.70.0 (signed by HashiCorp)
- Installing hashicorp/null v2.1.2...
- Installed hashicorp/null v2.1.2 (signed by HashiCorp)

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
dap@zathras terraform $ ls
total 56
-rw-r--r--  1 dap  staff   279 Oct 16 17:17 aws.tf
-rw-r--r--  1 dap  staff  1573 Oct 16 17:17 iam.tf
-rw-r--r--  1 dap  staff  8374 Oct 16 17:17 nodes.tf
-rw-r--r--  1 dap  staff   623 Oct 16 17:17 output.tf
-rw-r--r--  1 dap  staff  1001 Oct 16 17:17 vpc.tf
dap@zathras terraform $ vim aws.tf 
dap@zathras terraform $ ls -l
total 56
-rw-r--r--  1 dap  staff   284 Oct 16 17:18 aws.tf
-rw-r--r--  1 dap  staff  1573 Oct 16 17:17 iam.tf
-rw-r--r--  1 dap  staff  8374 Oct 16 17:17 nodes.tf
-rw-r--r--  1 dap  staff   623 Oct 16 17:17 output.tf
-rw-r--r--  1 dap  staff  1001 Oct 16 17:17 vpc.tf
dap@zathras terraform $ rm -f .terraform/
plugins/           terraform.tfstate  
dap@zathras terraform $ rm -rf .terraform/
dap@zathras terraform $ terraform init

Initializing the backend...

Successfully configured the backend "s3"! Terraform will automatically
use this backend unless the backend configuration changes.

Initializing provider plugins...
- Finding hashicorp/aws versions matching "~> 2.0"...
- Finding hashicorp/null versions matching "2.1.2"...
- Installing hashicorp/aws v2.70.0...
- Installed hashicorp/aws v2.70.0 (signed by HashiCorp)
- Installing hashicorp/null v2.1.2...
- Installed hashicorp/null v2.1.2 (signed by HashiCorp)

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
dap@zathras terraform $ terraform apply

Error: Missing required argument

  on nodes.tf line 41, in resource "aws_instance" "db":
  41:   ebs_block_device {

The argument "device_name" is required, but no definition was found.

dap@zathras terraform $ ls -l
total 56
-rw-r--r--  1 dap  staff   284 Oct 16 17:18 aws.tf
-rw-r--r--  1 dap  staff  1573 Oct 16 17:17 iam.tf
-rw-r--r--  1 dap  staff  8374 Oct 16 17:17 nodes.tf
-rw-r--r--  1 dap  staff   623 Oct 16 17:17 output.tf
-rw-r--r--  1 dap  staff  1001 Oct 16 17:17 vpc.tf
dap@zathras terraform $ vim nodes.tf 
dap@zathras terraform $ vim nodes.tf 
dap@zathras terraform $ terraform apply

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_iam_instance_profile.primary will be created
  + resource "aws_iam_instance_profile" "primary" {
      + arn         = (known after apply)
      + create_date = (known after apply)
      + id          = (known after apply)
      + name        = (known after apply)
      + path        = "/"
      + role        = "primary"
      + roles       = (known after apply)
      + unique_id   = (known after apply)
    }

  # aws_iam_role.primary will be created
  + resource "aws_iam_role" "primary" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "ec2.amazonaws.com"
                        }
                      + Sid       = ""
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + max_session_duration  = 3600
      + name                  = "primary"
      + path                  = "/"
      + unique_id             = (known after apply)
    }

  # aws_iam_role_policy.read_ec2 will be created
  + resource "aws_iam_role_policy" "read_ec2" {
      + id     = (known after apply)
      + name   = (known after apply)
      + policy = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = "ec2:Describe*"
                      + Effect   = "Allow"
                      + Resource = "*"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + role   = (known after apply)
    }

  # aws_iam_role_policy.read_from_s3_bucket will be created
  + resource "aws_iam_role_policy" "read_from_s3_bucket" {
      + id     = (known after apply)
      + name   = (known after apply)
      + policy = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = [
                          + "s3:List*",
                        ]
                      + Effect   = "Allow"
                      + Resource = [
                          + "arn:aws:s3:::oxide-cockroachdb-exploration",
                        ]
                    },
                  + {
                      + Action   = [
                          + "s3:Get*",
                        ]
                      + Effect   = "Allow"
                      + Resource = [
                          + "arn:aws:s3:::oxide-cockroachdb-exploration/*",
                        ]
                    },
                  + {
                      + Action   = "ec2:Describe*"
                      + Effect   = "Allow"
                      + Resource = [
                          + "arn:aws:ec2:us-west-2:*",
                        ]
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + role   = (known after apply)
    }

  # aws_instance.db_nvme[0] will be created
  + resource "aws_instance" "db_nvme" {
      + ami                          = "ami-01bb2865054e219c1"
      + arn                          = (known after apply)
      + associate_public_ip_address  = true
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + iam_instance_profile         = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "i3.large"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = "dap-terraform"
      + network_interface_id         = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tags                         = {
          + "Name"    = "crdb_exploration_nvmedb_1"
          + "Project" = "crdb_exploration"
          + "Role"    = "crdb_exploration_nvmedb"
        }
      + tenancy                      = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }
    }

  # aws_instance.db_nvme[1] will be created
  + resource "aws_instance" "db_nvme" {
      + ami                          = "ami-01bb2865054e219c1"
      + arn                          = (known after apply)
      + associate_public_ip_address  = true
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + iam_instance_profile         = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "i3.large"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = "dap-terraform"
      + network_interface_id         = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tags                         = {
          + "Name"    = "crdb_exploration_nvmedb_2"
          + "Project" = "crdb_exploration"
          + "Role"    = "crdb_exploration_nvmedb"
        }
      + tenancy                      = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }
    }

  # aws_instance.db_nvme[2] will be created
  + resource "aws_instance" "db_nvme" {
      + ami                          = "ami-01bb2865054e219c1"
      + arn                          = (known after apply)
      + associate_public_ip_address  = true
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + iam_instance_profile         = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "i3.large"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = "dap-terraform"
      + network_interface_id         = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tags                         = {
          + "Name"    = "crdb_exploration_nvmedb_3"
          + "Project" = "crdb_exploration"
          + "Role"    = "crdb_exploration_nvmedb"
        }
      + tenancy                      = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }
    }

  # aws_instance.loadgen[0] will be created
  + resource "aws_instance" "loadgen" {
      + ami                          = "ami-012f34b61b75182e8"
      + arn                          = (known after apply)
      + associate_public_ip_address  = true
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + iam_instance_profile         = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "c4.large"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = "dap-terraform"
      + network_interface_id         = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tags                         = {
          + "Name"    = "crdb_exploration_loadgen_0"
          + "Project" = "crdb_exploration"
          + "Role"    = "crdb_exploration_loadgen"
        }
      + tenancy                      = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = true
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = 10
          + volume_type           = (known after apply)
        }
    }

  # aws_instance.mon[0] will be created
  + resource "aws_instance" "mon" {
      + ami                          = "ami-012f34b61b75182e8"
      + arn                          = (known after apply)
      + associate_public_ip_address  = true
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + iam_instance_profile         = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "t2.medium"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = "dap-terraform"
      + network_interface_id         = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tags                         = {
          + "Name"    = "crdb_exploration_mon_0"
          + "Project" = "crdb_exploration"
          + "Role"    = "crdb_exploration_mon"
        }
      + tenancy                      = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = true
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = 30
          + volume_type           = (known after apply)
        }
    }

  # aws_internet_gateway.gw will be created
  + resource "aws_internet_gateway" "gw" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + owner_id = (known after apply)
      + tags     = {
          + "Name" = "crdb_exploration"
        }
      + vpc_id   = (known after apply)
    }

  # aws_route.r will be created
  + resource "aws_route" "r" {
      + destination_cidr_block     = "0.0.0.0/0"
      + destination_prefix_list_id = (known after apply)
      + egress_only_gateway_id     = (known after apply)
      + gateway_id                 = (known after apply)
      + id                         = (known after apply)
      + instance_id                = (known after apply)
      + instance_owner_id          = (known after apply)
      + nat_gateway_id             = (known after apply)
      + network_interface_id       = (known after apply)
      + origin                     = (known after apply)
      + route_table_id             = (known after apply)
      + state                      = (known after apply)
    }

  # aws_security_group.crdb_exploration will be created
  + resource "aws_security_group" "crdb_exploration" {
      + arn                    = (known after apply)
      + description            = "Managed by Terraform"
      + egress                 = (known after apply)
      + id                     = (known after apply)
      + ingress                = (known after apply)
      + name                   = "crdb_exploration"
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name" = "crdb_exploration"
        }
      + vpc_id                 = (known after apply)
    }

  # aws_security_group_rule.crdb_exploration_local_in will be created
  + resource "aws_security_group_rule" "crdb_exploration_local_in" {
      + from_port                = 0
      + id                       = (known after apply)
      + protocol                 = "-1"
      + security_group_id        = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 65536
      + type                     = "ingress"
    }

  # aws_security_group_rule.crdb_exploration_out will be created
  + resource "aws_security_group_rule" "crdb_exploration_out" {
      + cidr_blocks              = [
          + "0.0.0.0/0",
        ]
      + from_port                = 0
      + id                       = (known after apply)
      + protocol                 = "-1"
      + security_group_id        = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 65536
      + type                     = "egress"
    }

  # aws_security_group_rule.crdb_exploration_ssh will be created
  + resource "aws_security_group_rule" "crdb_exploration_ssh" {
      + cidr_blocks              = [
          + "0.0.0.0/0",
        ]
      + from_port                = 22
      + id                       = (known after apply)
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 22
      + type                     = "ingress"
    }

  # aws_subnet.crdb_exploration will be created
  + resource "aws_subnet" "crdb_exploration" {
      + arn                             = (known after apply)
      + assign_ipv6_address_on_creation = false
      + availability_zone               = "us-west-2a"
      + availability_zone_id            = (known after apply)
      + cidr_block                      = "192.168.1.0/24"
      + id                              = (known after apply)
      + ipv6_cidr_block                 = (known after apply)
      + ipv6_cidr_block_association_id  = (known after apply)
      + map_public_ip_on_launch         = false
      + owner_id                        = (known after apply)
      + tags                            = {
          + "Name" = "crdb_exploration"
        }
      + vpc_id                          = (known after apply)
    }

  # aws_vpc.crdb_exploration will be created
  + resource "aws_vpc" "crdb_exploration" {
      + arn                              = (known after apply)
      + assign_generated_ipv6_cidr_block = false
      + cidr_block                       = "192.168.0.0/16"
      + default_network_acl_id           = (known after apply)
      + default_route_table_id           = (known after apply)
      + default_security_group_id        = (known after apply)
      + dhcp_options_id                  = (known after apply)
      + enable_classiclink               = (known after apply)
      + enable_classiclink_dns_support   = (known after apply)
      + enable_dns_hostnames             = true
      + enable_dns_support               = true
      + id                               = (known after apply)
      + instance_tenancy                 = "default"
      + ipv6_association_id              = (known after apply)
      + ipv6_cidr_block                  = (known after apply)
      + main_route_table_id              = (known after apply)
      + owner_id                         = (known after apply)
      + tags                             = {
          + "Name" = "crdb_exploration"
        }
    }

  # null_resource.cluster_config_nvme[0] will be created
  + resource "null_resource" "cluster_config_nvme" {
      + id       = (known after apply)
      + triggers = (known after apply)
    }

  # null_resource.cluster_config_nvme[1] will be created
  + resource "null_resource" "cluster_config_nvme" {
      + id       = (known after apply)
      + triggers = (known after apply)
    }

  # null_resource.cluster_config_nvme[2] will be created
  + resource "null_resource" "cluster_config_nvme" {
      + id       = (known after apply)
      + triggers = (known after apply)
    }

Plan: 20 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_iam_role.primary: Creating...
aws_vpc.crdb_exploration: Creating...
aws_vpc.crdb_exploration: Creation complete after 3s [id=vpc-0e01d5cfe95fb12af]
aws_internet_gateway.gw: Creating...
aws_subnet.crdb_exploration: Creating...
aws_security_group.crdb_exploration: Creating...
aws_subnet.crdb_exploration: Creation complete after 2s [id=subnet-085deecfd10a92421]
aws_internet_gateway.gw: Creation complete after 2s [id=igw-04fa14e3cc1ece621]
aws_route.r: Creating...
aws_route.r: Creation complete after 1s [id=r-rtb-0d8c8c0e40cdfc1dd1080289494]
aws_security_group.crdb_exploration: Creation complete after 3s [id=sg-0addf609b0e6b2c3c]
aws_security_group_rule.crdb_exploration_out: Creating...
aws_security_group_rule.crdb_exploration_ssh: Creating...
aws_security_group_rule.crdb_exploration_local_in: Creating...
aws_security_group_rule.crdb_exploration_out: Creation complete after 0s [id=sgrule-2831093523]
aws_security_group_rule.crdb_exploration_local_in: Creation complete after 1s [id=sgrule-855786104]
aws_security_group_rule.crdb_exploration_ssh: Creation complete after 2s [id=sgrule-3808307800]

Error: Error creating IAM Role primary: EntityAlreadyExists: Role with name primary already exists.
	status code: 409, request id: 67796e1c-77b9-4bd0-8fed-3f90b9bb3363

  on iam.tf line 7, in resource "aws_iam_role" "primary":
   7: resource "aws_iam_role" "primary" {


dap@zathras terraform $ vim nodes.tf 
dap@zathras terraform $ vim aws.tf 
dap@zathras terraform $ #terraform destroy
dap@zathras terraform $ vim aws.tf 
dap@zathras terraform $ terraform destroy
aws_vpc.crdb_exploration: Refreshing state... [id=vpc-0e01d5cfe95fb12af]
aws_internet_gateway.gw: Refreshing state... [id=igw-04fa14e3cc1ece621]
aws_security_group.crdb_exploration: Refreshing state... [id=sg-0addf609b0e6b2c3c]
aws_subnet.crdb_exploration: Refreshing state... [id=subnet-085deecfd10a92421]
aws_route.r: Refreshing state... [id=r-rtb-0d8c8c0e40cdfc1dd1080289494]
aws_security_group_rule.crdb_exploration_local_in: Refreshing state... [id=sgrule-855786104]
aws_security_group_rule.crdb_exploration_ssh: Refreshing state... [id=sgrule-3808307800]
aws_security_group_rule.crdb_exploration_out: Refreshing state... [id=sgrule-2831093523]

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  - destroy

Terraform will perform the following actions:

  # aws_internet_gateway.gw will be destroyed
  - resource "aws_internet_gateway" "gw" {
      - arn      = "arn:aws:ec2:us-west-2:128433874814:internet-gateway/igw-04fa14e3cc1ece621" -> null
      - id       = "igw-04fa14e3cc1ece621" -> null
      - owner_id = "128433874814" -> null
      - tags     = {
          - "Name" = "crdb_exploration"
        } -> null
      - vpc_id   = "vpc-0e01d5cfe95fb12af" -> null
    }

  # aws_route.r will be destroyed
  - resource "aws_route" "r" {
      - destination_cidr_block = "0.0.0.0/0" -> null
      - gateway_id             = "igw-04fa14e3cc1ece621" -> null
      - id                     = "r-rtb-0d8c8c0e40cdfc1dd1080289494" -> null
      - origin                 = "CreateRoute" -> null
      - route_table_id         = "rtb-0d8c8c0e40cdfc1dd" -> null
      - state                  = "active" -> null
    }

  # aws_security_group.crdb_exploration will be destroyed
  - resource "aws_security_group" "crdb_exploration" {
      - arn                    = "arn:aws:ec2:us-west-2:128433874814:security-group/sg-0addf609b0e6b2c3c" -> null
      - description            = "Managed by Terraform" -> null
      - egress                 = [
          - {
              - cidr_blocks      = [
                  - "0.0.0.0/0",
                ]
              - description      = ""
              - from_port        = 0
              - ipv6_cidr_blocks = []
              - prefix_list_ids  = []
              - protocol         = "-1"
              - security_groups  = []
              - self             = false
              - to_port          = 0
            },
        ] -> null
      - id                     = "sg-0addf609b0e6b2c3c" -> null
      - ingress                = [
          - {
              - cidr_blocks      = [
                  - "0.0.0.0/0",
                ]
              - description      = ""
              - from_port        = 22
              - ipv6_cidr_blocks = []
              - prefix_list_ids  = []
              - protocol         = "tcp"
              - security_groups  = []
              - self             = false
              - to_port          = 22
            },
          - {
              - cidr_blocks      = []
              - description      = ""
              - from_port        = 0
              - ipv6_cidr_blocks = []
              - prefix_list_ids  = []
              - protocol         = "-1"
              - security_groups  = []
              - self             = true
              - to_port          = 0
            },
        ] -> null
      - name                   = "crdb_exploration" -> null
      - owner_id               = "128433874814" -> null
      - revoke_rules_on_delete = false -> null
      - tags                   = {
          - "Name" = "crdb_exploration"
        } -> null
      - vpc_id                 = "vpc-0e01d5cfe95fb12af" -> null
    }

  # aws_security_group_rule.crdb_exploration_local_in will be destroyed
  - resource "aws_security_group_rule" "crdb_exploration_local_in" {
      - cidr_blocks              = [] -> null
      - from_port                = 0 -> null
      - id                       = "sgrule-855786104" -> null
      - ipv6_cidr_blocks         = [] -> null
      - prefix_list_ids          = [] -> null
      - protocol                 = "-1" -> null
      - security_group_id        = "sg-0addf609b0e6b2c3c" -> null
      - self                     = false -> null
      - source_security_group_id = "sg-0addf609b0e6b2c3c" -> null
      - to_port                  = 0 -> null
      - type                     = "ingress" -> null
    }

  # aws_security_group_rule.crdb_exploration_out will be destroyed
  - resource "aws_security_group_rule" "crdb_exploration_out" {
      - cidr_blocks       = [
          - "0.0.0.0/0",
        ] -> null
      - from_port         = 0 -> null
      - id                = "sgrule-2831093523" -> null
      - ipv6_cidr_blocks  = [] -> null
      - prefix_list_ids   = [] -> null
      - protocol          = "-1" -> null
      - security_group_id = "sg-0addf609b0e6b2c3c" -> null
      - self              = false -> null
      - to_port           = 0 -> null
      - type              = "egress" -> null
    }

  # aws_security_group_rule.crdb_exploration_ssh will be destroyed
  - resource "aws_security_group_rule" "crdb_exploration_ssh" {
      - cidr_blocks       = [
          - "0.0.0.0/0",
        ] -> null
      - from_port         = 22 -> null
      - id                = "sgrule-3808307800" -> null
      - ipv6_cidr_blocks  = [] -> null
      - prefix_list_ids   = [] -> null
      - protocol          = "tcp" -> null
      - security_group_id = "sg-0addf609b0e6b2c3c" -> null
      - self              = false -> null
      - to_port           = 22 -> null
      - type              = "ingress" -> null
    }

  # aws_subnet.crdb_exploration will be destroyed
  - resource "aws_subnet" "crdb_exploration" {
      - arn                             = "arn:aws:ec2:us-west-2:128433874814:subnet/subnet-085deecfd10a92421" -> null
      - assign_ipv6_address_on_creation = false -> null
      - availability_zone               = "us-west-2a" -> null
      - availability_zone_id            = "usw2-az2" -> null
      - cidr_block                      = "192.168.1.0/24" -> null
      - id                              = "subnet-085deecfd10a92421" -> null
      - map_public_ip_on_launch         = false -> null
      - owner_id                        = "128433874814" -> null
      - tags                            = {
          - "Name" = "crdb_exploration"
        } -> null
      - vpc_id                          = "vpc-0e01d5cfe95fb12af" -> null
    }

  # aws_vpc.crdb_exploration will be destroyed
  - resource "aws_vpc" "crdb_exploration" {
      - arn                              = "arn:aws:ec2:us-west-2:128433874814:vpc/vpc-0e01d5cfe95fb12af" -> null
      - assign_generated_ipv6_cidr_block = false -> null
      - cidr_block                       = "192.168.0.0/16" -> null
      - default_network_acl_id           = "acl-0302124ebacb4e4bb" -> null
      - default_route_table_id           = "rtb-0d8c8c0e40cdfc1dd" -> null
      - default_security_group_id        = "sg-0faa38a7b9bf3aab9" -> null
      - dhcp_options_id                  = "dopt-e5019a9d" -> null
      - enable_classiclink               = false -> null
      - enable_classiclink_dns_support   = false -> null
      - enable_dns_hostnames             = true -> null
      - enable_dns_support               = true -> null
      - id                               = "vpc-0e01d5cfe95fb12af" -> null
      - instance_tenancy                 = "default" -> null
      - main_route_table_id              = "rtb-0d8c8c0e40cdfc1dd" -> null
      - owner_id                         = "128433874814" -> null
      - tags                             = {
          - "Name" = "crdb_exploration"
        } -> null
    }

Plan: 0 to add, 0 to change, 8 to destroy.

Changes to Outputs:
  - db_external_ip = [] -> null
  - db_internal_ip = [] -> null

Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only 'yes' will be accepted to confirm.

  Enter a value: no

Destroy cancelled.
dap@zathras terraform $ vim aws.tf 
dap@zathras terraform $ terraform apply
aws_vpc.crdb_exploration: Refreshing state... [id=vpc-0e01d5cfe95fb12af]
aws_security_group.crdb_exploration: Refreshing state... [id=sg-0addf609b0e6b2c3c]
aws_internet_gateway.gw: Refreshing state... [id=igw-04fa14e3cc1ece621]
aws_subnet.crdb_exploration: Refreshing state... [id=subnet-085deecfd10a92421]
aws_route.r: Refreshing state... [id=r-rtb-0d8c8c0e40cdfc1dd1080289494]
aws_security_group_rule.crdb_exploration_ssh: Refreshing state... [id=sgrule-3808307800]
aws_security_group_rule.crdb_exploration_local_in: Refreshing state... [id=sgrule-855786104]
aws_security_group_rule.crdb_exploration_out: Refreshing state... [id=sgrule-2831093523]

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_iam_instance_profile.primary will be created
  + resource "aws_iam_instance_profile" "primary" {
      + arn         = (known after apply)
      + create_date = (known after apply)
      + id          = (known after apply)
      + name        = (known after apply)
      + path        = "/"
      + role        = "primary"
      + roles       = (known after apply)
      + unique_id   = (known after apply)
    }

  # aws_iam_role.primary will be created
  + resource "aws_iam_role" "primary" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "ec2.amazonaws.com"
                        }
                      + Sid       = ""
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + max_session_duration  = 3600
      + name                  = "primary"
      + path                  = "/"
      + unique_id             = (known after apply)
    }

  # aws_iam_role_policy.read_ec2 will be created
  + resource "aws_iam_role_policy" "read_ec2" {
      + id     = (known after apply)
      + name   = (known after apply)
      + policy = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = "ec2:Describe*"
                      + Effect   = "Allow"
                      + Resource = "*"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + role   = (known after apply)
    }

  # aws_iam_role_policy.read_from_s3_bucket will be created
  + resource "aws_iam_role_policy" "read_from_s3_bucket" {
      + id     = (known after apply)
      + name   = (known after apply)
      + policy = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = [
                          + "s3:List*",
                        ]
                      + Effect   = "Allow"
                      + Resource = [
                          + "arn:aws:s3:::oxide-cockroachdb-exploration",
                        ]
                    },
                  + {
                      + Action   = [
                          + "s3:Get*",
                        ]
                      + Effect   = "Allow"
                      + Resource = [
                          + "arn:aws:s3:::oxide-cockroachdb-exploration/*",
                        ]
                    },
                  + {
                      + Action   = "ec2:Describe*"
                      + Effect   = "Allow"
                      + Resource = [
                          + "arn:aws:ec2:us-west-2:*",
                        ]
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + role   = (known after apply)
    }

  # aws_instance.db_nvme[0] will be created
  + resource "aws_instance" "db_nvme" {
      + ami                          = "ami-01bb2865054e219c1"
      + arn                          = (known after apply)
      + associate_public_ip_address  = true
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + iam_instance_profile         = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "i3.large"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = "dap-terraform"
      + network_interface_id         = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tags                         = {
          + "Name"    = "crdb_exploration_nvmedb_1"
          + "Project" = "crdb_exploration"
          + "Role"    = "crdb_exploration_nvmedb"
        }
      + tenancy                      = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }
    }

  # aws_instance.db_nvme[1] will be created
  + resource "aws_instance" "db_nvme" {
      + ami                          = "ami-01bb2865054e219c1"
      + arn                          = (known after apply)
      + associate_public_ip_address  = true
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + iam_instance_profile         = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "i3.large"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = "dap-terraform"
      + network_interface_id         = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tags                         = {
          + "Name"    = "crdb_exploration_nvmedb_2"
          + "Project" = "crdb_exploration"
          + "Role"    = "crdb_exploration_nvmedb"
        }
      + tenancy                      = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }
    }

  # aws_instance.db_nvme[2] will be created
  + resource "aws_instance" "db_nvme" {
      + ami                          = "ami-01bb2865054e219c1"
      + arn                          = (known after apply)
      + associate_public_ip_address  = true
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + iam_instance_profile         = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "i3.large"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = "dap-terraform"
      + network_interface_id         = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tags                         = {
          + "Name"    = "crdb_exploration_nvmedb_3"
          + "Project" = "crdb_exploration"
          + "Role"    = "crdb_exploration_nvmedb"
        }
      + tenancy                      = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }
    }

  # aws_instance.loadgen[0] will be created
  + resource "aws_instance" "loadgen" {
      + ami                          = "ami-012f34b61b75182e8"
      + arn                          = (known after apply)
      + associate_public_ip_address  = true
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + iam_instance_profile         = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "c4.large"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = "dap-terraform"
      + network_interface_id         = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tags                         = {
          + "Name"    = "crdb_exploration_loadgen_0"
          + "Project" = "crdb_exploration"
          + "Role"    = "crdb_exploration_loadgen"
        }
      + tenancy                      = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = true
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = 10
          + volume_type           = (known after apply)
        }
    }

  # aws_instance.mon[0] will be created
  + resource "aws_instance" "mon" {
      + ami                          = "ami-012f34b61b75182e8"
      + arn                          = (known after apply)
      + associate_public_ip_address  = true
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + iam_instance_profile         = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "t2.medium"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)
      + key_name                     = "dap-terraform"
      + network_interface_id         = (known after apply)
      + outpost_arn                  = (known after apply)
      + password_data                = (known after apply)
      + placement_group              = (known after apply)
      + primary_network_interface_id = (known after apply)
      + private_dns                  = (known after apply)
      + private_ip                   = (known after apply)
      + public_dns                   = (known after apply)
      + public_ip                    = (known after apply)
      + security_groups              = (known after apply)
      + source_dest_check            = true
      + subnet_id                    = (known after apply)
      + tags                         = {
          + "Name"    = "crdb_exploration_mon_0"
          + "Project" = "crdb_exploration"
          + "Role"    = "crdb_exploration_mon"
        }
      + tenancy                      = (known after apply)
      + volume_tags                  = (known after apply)
      + vpc_security_group_ids       = (known after apply)

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_interface_id  = (known after apply)
        }

      + root_block_device {
          + delete_on_termination = true
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = 30
          + volume_type           = (known after apply)
        }
    }

  # aws_internet_gateway.gw will be created
  + resource "aws_internet_gateway" "gw" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + owner_id = (known after apply)
      + tags     = {
          + "Name" = "crdb_exploration"
        }
      + vpc_id   = (known after apply)
    }

  # aws_route.r will be created
  + resource "aws_route" "r" {
      + destination_cidr_block     = "0.0.0.0/0"
      + destination_prefix_list_id = (known after apply)
      + egress_only_gateway_id     = (known after apply)
      + gateway_id                 = (known after apply)
      + id                         = (known after apply)
      + instance_id                = (known after apply)
      + instance_owner_id          = (known after apply)
      + nat_gateway_id             = (known after apply)
      + network_interface_id       = (known after apply)
      + origin                     = (known after apply)
      + route_table_id             = (known after apply)
      + state                      = (known after apply)
    }

  # aws_security_group.crdb_exploration will be created
  + resource "aws_security_group" "crdb_exploration" {
      + arn                    = (known after apply)
      + description            = "Managed by Terraform"
      + egress                 = (known after apply)
      + id                     = (known after apply)
      + ingress                = (known after apply)
      + name                   = "crdb_exploration"
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name" = "crdb_exploration"
        }
      + vpc_id                 = (known after apply)
    }

  # aws_security_group_rule.crdb_exploration_local_in will be created
  + resource "aws_security_group_rule" "crdb_exploration_local_in" {
      + from_port                = 0
      + id                       = (known after apply)
      + protocol                 = "-1"
      + security_group_id        = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 65536
      + type                     = "ingress"
    }

  # aws_security_group_rule.crdb_exploration_out will be created
  + resource "aws_security_group_rule" "crdb_exploration_out" {
      + cidr_blocks              = [
          + "0.0.0.0/0",
        ]
      + from_port                = 0
      + id                       = (known after apply)
      + protocol                 = "-1"
      + security_group_id        = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 65536
      + type                     = "egress"
    }

  # aws_security_group_rule.crdb_exploration_ssh will be created
  + resource "aws_security_group_rule" "crdb_exploration_ssh" {
      + cidr_blocks              = [
          + "0.0.0.0/0",
        ]
      + from_port                = 22
      + id                       = (known after apply)
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 22
      + type                     = "ingress"
    }

  # aws_subnet.crdb_exploration will be created
  + resource "aws_subnet" "crdb_exploration" {
      + arn                             = (known after apply)
      + assign_ipv6_address_on_creation = false
      + availability_zone               = "us-west-2a"
      + availability_zone_id            = (known after apply)
      + cidr_block                      = "192.168.1.0/24"
      + id                              = (known after apply)
      + ipv6_cidr_block                 = (known after apply)
      + ipv6_cidr_block_association_id  = (known after apply)
      + map_public_ip_on_launch         = false
      + owner_id                        = (known after apply)
      + tags                            = {
          + "Name" = "crdb_exploration"
        }
      + vpc_id                          = (known after apply)
    }

  # aws_vpc.crdb_exploration will be created
  + resource "aws_vpc" "crdb_exploration" {
      + arn                              = (known after apply)
      + assign_generated_ipv6_cidr_block = false
      + cidr_block                       = "192.168.0.0/16"
      + default_network_acl_id           = (known after apply)
      + default_route_table_id           = (known after apply)
      + default_security_group_id        = (known after apply)
      + dhcp_options_id                  = (known after apply)
      + enable_classiclink               = (known after apply)
      + enable_classiclink_dns_support   = (known after apply)
      + enable_dns_hostnames             = true
      + enable_dns_support               = true
      + id                               = (known after apply)
      + instance_tenancy                 = "default"
      + ipv6_association_id              = (known after apply)
      + ipv6_cidr_block                  = (known after apply)
      + main_route_table_id              = (known after apply)
      + owner_id                         = (known after apply)
      + tags                             = {
          + "Name" = "crdb_exploration"
        }
    }

  # null_resource.cluster_config_nvme[0] will be created
  + resource "null_resource" "cluster_config_nvme" {
      + id       = (known after apply)
      + triggers = (known after apply)
    }

  # null_resource.cluster_config_nvme[1] will be created
  + resource "null_resource" "cluster_config_nvme" {
      + id       = (known after apply)
      + triggers = (known after apply)
    }

  # null_resource.cluster_config_nvme[2] will be created
  + resource "null_resource" "cluster_config_nvme" {
      + id       = (known after apply)
      + triggers = (known after apply)
    }

Plan: 20 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + loadgen_external_ip = [
      + (known after apply),
    ]
  + loadgen_internal_ip = [
      + (known after apply),
    ]
  + mon_external_ip     = [
      + (known after apply),
    ]
  + mon_internal_ip     = [
      + (known after apply),
    ]
  + nvmedb_external_ip  = [
      + (known after apply),
      + (known after apply),
      + (known after apply),
    ]
  + nvmedb_internal_ip  = [
      + (known after apply),
      + (known after apply),
      + (known after apply),
    ]

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_iam_role.primary: Creating...
aws_vpc.crdb_exploration: Creating...
aws_vpc.crdb_exploration: Creation complete after 2s [id=vpc-071eea71e561fe3f2]
aws_internet_gateway.gw: Creating...
aws_security_group.crdb_exploration: Creating...
aws_subnet.crdb_exploration: Creating...
aws_internet_gateway.gw: Creation complete after 1s [id=igw-04ff69f7a356647b3]
aws_route.r: Creating...
aws_route.r: Creation complete after 1s [id=r-rtb-03b58f814fb510bed1080289494]
aws_security_group.crdb_exploration: Creation complete after 2s [id=sg-096b626e59b972c19]
aws_security_group_rule.crdb_exploration_out: Creating...
aws_security_group_rule.crdb_exploration_ssh: Creating...
aws_security_group_rule.crdb_exploration_local_in: Creating...
aws_security_group_rule.crdb_exploration_ssh: Creation complete after 0s [id=sgrule-2151619746]
aws_security_group_rule.crdb_exploration_out: Creation complete after 1s [id=sgrule-2564720198]
aws_security_group_rule.crdb_exploration_local_in: Creation complete after 1s [id=sgrule-3373942265]

Error: Error creating IAM Role primary: EntityAlreadyExists: Role with name primary already exists.
	status code: 409, request id: dda74e38-a541-435c-aec5-cbd32edee4c5

  on iam.tf line 7, in resource "aws_iam_role" "primary":
   7: resource "aws_iam_role" "primary" {



Error: Error creating subnet: InvalidParameterValue: Value (us-west-2a) for parameter availabilityZone is invalid. Subnets can currently only be created in the following availability zones: us-west-1a, us-west-1c.
	status code: 400, request id: 90d02439-ac27-4953-a568-cdfc2a5dbc83

  on vpc.tf line 17, in resource "aws_subnet" "crdb_exploration":
  17: resource "aws_subnet" "crdb_exploration" {


dap@zathras terraform $ terraform destroy
aws_vpc.crdb_exploration: Refreshing state... [id=vpc-071eea71e561fe3f2]
aws_internet_gateway.gw: Refreshing state... [id=igw-04ff69f7a356647b3]
aws_security_group.crdb_exploration: Refreshing state... [id=sg-096b626e59b972c19]
aws_route.r: Refreshing state... [id=r-rtb-03b58f814fb510bed1080289494]
aws_security_group_rule.crdb_exploration_out: Refreshing state... [id=sgrule-2564720198]
aws_security_group_rule.crdb_exploration_local_in: Refreshing state... [id=sgrule-3373942265]
aws_security_group_rule.crdb_exploration_ssh: Refreshing state... [id=sgrule-2151619746]

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  - destroy

Terraform will perform the following actions:

  # aws_internet_gateway.gw will be destroyed
  - resource "aws_internet_gateway" "gw" {
      - arn      = "arn:aws:ec2:us-west-1:128433874814:internet-gateway/igw-04ff69f7a356647b3" -> null
      - id       = "igw-04ff69f7a356647b3" -> null
      - owner_id = "128433874814" -> null
      - tags     = {
          - "Name" = "crdb_exploration"
        } -> null
      - vpc_id   = "vpc-071eea71e561fe3f2" -> null
    }

  # aws_route.r will be destroyed
  - resource "aws_route" "r" {
      - destination_cidr_block = "0.0.0.0/0" -> null
      - gateway_id             = "igw-04ff69f7a356647b3" -> null
      - id                     = "r-rtb-03b58f814fb510bed1080289494" -> null
      - origin                 = "CreateRoute" -> null
      - route_table_id         = "rtb-03b58f814fb510bed" -> null
      - state                  = "active" -> null
    }

  # aws_security_group.crdb_exploration will be destroyed
  - resource "aws_security_group" "crdb_exploration" {
      - arn                    = "arn:aws:ec2:us-west-1:128433874814:security-group/sg-096b626e59b972c19" -> null
      - description            = "Managed by Terraform" -> null
      - egress                 = [
          - {
              - cidr_blocks      = [
                  - "0.0.0.0/0",
                ]
              - description      = ""
              - from_port        = 0
              - ipv6_cidr_blocks = []
              - prefix_list_ids  = []
              - protocol         = "-1"
              - security_groups  = []
              - self             = false
              - to_port          = 0
            },
        ] -> null
      - id                     = "sg-096b626e59b972c19" -> null
      - ingress                = [
          - {
              - cidr_blocks      = [
                  - "0.0.0.0/0",
                ]
              - description      = ""
              - from_port        = 22
              - ipv6_cidr_blocks = []
              - prefix_list_ids  = []
              - protocol         = "tcp"
              - security_groups  = []
              - self             = false
              - to_port          = 22
            },
          - {
              - cidr_blocks      = []
              - description      = ""
              - from_port        = 0
              - ipv6_cidr_blocks = []
              - prefix_list_ids  = []
              - protocol         = "-1"
              - security_groups  = []
              - self             = true
              - to_port          = 0
            },
        ] -> null
      - name                   = "crdb_exploration" -> null
      - owner_id               = "128433874814" -> null
      - revoke_rules_on_delete = false -> null
      - tags                   = {
          - "Name" = "crdb_exploration"
        } -> null
      - vpc_id                 = "vpc-071eea71e561fe3f2" -> null
    }

  # aws_security_group_rule.crdb_exploration_local_in will be destroyed
  - resource "aws_security_group_rule" "crdb_exploration_local_in" {
      - cidr_blocks              = [] -> null
      - from_port                = 0 -> null
      - id                       = "sgrule-3373942265" -> null
      - ipv6_cidr_blocks         = [] -> null
      - prefix_list_ids          = [] -> null
      - protocol                 = "-1" -> null
      - security_group_id        = "sg-096b626e59b972c19" -> null
      - self                     = false -> null
      - source_security_group_id = "sg-096b626e59b972c19" -> null
      - to_port                  = 0 -> null
      - type                     = "ingress" -> null
    }

  # aws_security_group_rule.crdb_exploration_out will be destroyed
  - resource "aws_security_group_rule" "crdb_exploration_out" {
      - cidr_blocks       = [
          - "0.0.0.0/0",
        ] -> null
      - from_port         = 0 -> null
      - id                = "sgrule-2564720198" -> null
      - ipv6_cidr_blocks  = [] -> null
      - prefix_list_ids   = [] -> null
      - protocol          = "-1" -> null
      - security_group_id = "sg-096b626e59b972c19" -> null
      - self              = false -> null
      - to_port           = 0 -> null
      - type              = "egress" -> null
    }

  # aws_security_group_rule.crdb_exploration_ssh will be destroyed
  - resource "aws_security_group_rule" "crdb_exploration_ssh" {
      - cidr_blocks       = [
          - "0.0.0.0/0",
        ] -> null
      - from_port         = 22 -> null
      - id                = "sgrule-2151619746" -> null
      - ipv6_cidr_blocks  = [] -> null
      - prefix_list_ids   = [] -> null
      - protocol          = "tcp" -> null
      - security_group_id = "sg-096b626e59b972c19" -> null
      - self              = false -> null
      - to_port           = 22 -> null
      - type              = "ingress" -> null
    }

  # aws_vpc.crdb_exploration will be destroyed
  - resource "aws_vpc" "crdb_exploration" {
      - arn                              = "arn:aws:ec2:us-west-1:128433874814:vpc/vpc-071eea71e561fe3f2" -> null
      - assign_generated_ipv6_cidr_block = false -> null
      - cidr_block                       = "192.168.0.0/16" -> null
      - default_network_acl_id           = "acl-0f0c4811b5346c481" -> null
      - default_route_table_id           = "rtb-03b58f814fb510bed" -> null
      - default_security_group_id        = "sg-0c88f04cd7e55fbd8" -> null
      - dhcp_options_id                  = "dopt-59b8a13e" -> null
      - enable_classiclink               = false -> null
      - enable_classiclink_dns_support   = false -> null
      - enable_dns_hostnames             = true -> null
      - enable_dns_support               = true -> null
      - id                               = "vpc-071eea71e561fe3f2" -> null
      - instance_tenancy                 = "default" -> null
      - main_route_table_id              = "rtb-03b58f814fb510bed" -> null
      - owner_id                         = "128433874814" -> null
      - tags                             = {
          - "Name" = "crdb_exploration"
        } -> null
    }

Plan: 0 to add, 0 to change, 7 to destroy.

Changes to Outputs:
  - db_external_ip      = [] -> null
  - db_internal_ip      = [] -> null
  - loadgen_external_ip = [
      - null,
    ] -> null
  - loadgen_internal_ip = [
      - null,
    ] -> null
  - mon_external_ip     = [
      - null,
    ] -> null
  - mon_internal_ip     = [
      - null,
    ] -> null
  - nvmedb_external_ip  = [
      - null,
      - null,
      - null,
    ] -> null
  - nvmedb_internal_ip  = [
      - null,
      - null,
      - null,
    ] -> null

Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only 'yes' will be accepted to confirm.

  Enter a value: yes

aws_security_group_rule.crdb_exploration_out: Destroying... [id=sgrule-2564720198]
aws_security_group_rule.crdb_exploration_ssh: Destroying... [id=sgrule-2151619746]
aws_security_group_rule.crdb_exploration_local_in: Destroying... [id=sgrule-3373942265]
aws_route.r: Destroying... [id=r-rtb-03b58f814fb510bed1080289494]
aws_route.r: Destruction complete after 0s
aws_internet_gateway.gw: Destroying... [id=igw-04ff69f7a356647b3]
aws_security_group_rule.crdb_exploration_local_in: Destruction complete after 1s
aws_security_group_rule.crdb_exploration_ssh: Destruction complete after 1s
aws_security_group_rule.crdb_exploration_out: Destruction complete after 2s
aws_security_group.crdb_exploration: Destroying... [id=sg-096b626e59b972c19]
aws_security_group.crdb_exploration: Destruction complete after 0s
aws_internet_gateway.gw: Still destroying... [id=igw-04ff69f7a356647b3, 10s elapsed]
aws_internet_gateway.gw: Destruction complete after 11s
aws_vpc.crdb_exploration: Destroying... [id=vpc-071eea71e561fe3f2]
aws_vpc.crdb_exploration: Destruction complete after 0s

Destroy complete! Resources: 7 destroyed.
dap@zathras terraform $ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   aws.tf
	modified:   nodes.tf

no changes added to commit (use "git add" and/or "git commit -a")
dap@zathras terraform $ terraform destroy
Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only 'yes' will be accepted to confirm.

  Enter a value: yes


Destroy complete! Resources: 0 destroyed.
dap@zathras terraform $ vim aws.tf 
dap@zathras terraform $ terraform destroy
Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only 'yes' will be accepted to confirm.

  Enter a value: yes


Destroy complete! Resources: 0 destroyed.
dap@zathras terraform $ terraform refresh
Empty or non-existent state file.

Refresh will do nothing. Refresh does not error or return an erroneous
exit status because many automation scripts use refresh, plan, then apply
and may not have a state file yet for the first run.

dap@zathras terraform $ vim aws.tf 
dap@zathras terraform $ terraform refresh
Empty or non-existent state file.

Refresh will do nothing. Refresh does not error or return an erroneous
exit status because many automation scripts use refresh, plan, then apply
and may not have a state file yet for the first run.

dap@zathras terraform $ git diff
diff --git a/terraform/aws.tf b/terraform/aws.tf
index 909e202..bee4c2d 100644
--- a/terraform/aws.tf
+++ b/terraform/aws.tf
@@ -3,14 +3,14 @@
 terraform {
   backend "s3" {
     bucket = "oxide-terraform-backend"
-    key    = "crdb-exploration"
+    key    = "crdb-exploration-test"
     region = "us-west-2"
   }
 }
 
 provider "aws" {
   version = "~> 2.0"
-  region  = "us-west-2"
+  region  = "us-west-1"
 }
 
 provider "null" {
diff --git a/terraform/nodes.tf b/terraform/nodes.tf
index ddb876d..e727eb9 100644
--- a/terraform/nodes.tf
+++ b/terraform/nodes.tf
@@ -8,9 +8,9 @@ locals {
   mon_instance_type     = "t2.medium"
 
   // Count of cluster nodes to create.
-  ndbs = 5
+  ndbs = 0
   // Count of NVME cluster nodes to create.
-  ndbs_nvme = 0
+  ndbs_nvme = 3
 
   // This key should be imported into AWS and loaded into your SSH agent.
   ssh_key_name = "dap-terraform"
@@ -39,6 +39,7 @@ resource "aws_instance" "db" {
   iam_instance_profile        = aws_iam_instance_profile.primary.id
 
   ebs_block_device {
+    device_name = "crdbdev"
     volume_size = 60
     volume_type = "io1"
     iops = 1000
dap@zathras terraform $ vim aws.tf 
dap@zathras terraform $ cat aws.tf 
// Copyright 2020 Oxide Computer Company

terraform {
  backend "s3" {
    bucket = "oxide-terraform-backend"
    key    = "crdb-exploration-test"
    region = "us-west-2"
  }
}

provider "aws" {
  version = "~> 2.0"
  region  = "us-west-1"
}

provider "null" {
  version = "2.1.2"
}
dap@zathras terraform $ 
